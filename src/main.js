const { app, BrowserWindow, ipcMain, shell, dialog, Menu } = require('electron')
const { autoUpdater } = require('electron-updater')
const path = require('path')
const { pipeline } = require('stream/promises')
const fs = require('fs')
const { spawn } = require('child_process')
const drivelist = require('drivelist')
const got = require('got')
const StreamZip = require('node-stream-zip')
const sudo = require('sudo-prompt')
const Store = require('electron-store')
const lzma = require('lzma-native')
const store = new Store()

// Configure auto-updater for public generic feed (generated by electron-builder publish)
autoUpdater.logger = console
autoUpdater.autoDownload = true
autoUpdater.autoInstallOnAppQuit = true

// Palpable API URLs
const PALPABLE_OS_URL = 'https://palpable.technology/api/download/palpable-os'
const PALPABLE_AUTH_URL = 'https://palpable.technology/auth/imager'
const PALPABLE_API_URL = 'https://palpable.technology/api'

let mainWindow = null
let authWindow = null

// Custom protocol for OAuth callback
const PROTOCOL = 'palpable-imager'

function createWindow() {
  mainWindow = new BrowserWindow({
    width: 800,
    height: 600,
    minWidth: 600,
    minHeight: 500,
    backgroundColor: '#0a0a0a',
    titleBarStyle: 'hiddenInset',
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js')
    },
    icon: path.join(__dirname, '../assets/icon.png')
  })

  mainWindow.loadFile(path.join(__dirname, 'index.html'))

  // Open DevTools in development
  if (process.argv.includes('--dev')) {
    mainWindow.webContents.openDevTools()
  }
}

// Register custom protocol for OAuth callback
app.setAsDefaultProtocolClient(PROTOCOL)

// Create application menu
function createApplicationMenu() {
  const isMac = process.platform === 'darwin'

  const template = [
    // App Menu (macOS only)
    ...(isMac ? [{
      label: app.name,
      submenu: [
        { role: 'about' },
        { type: 'separator' },
        {
          label: 'Check for Updates...',
          click: async () => {
            const result = await checkForUpdates()
            if (result.success) {
              if (result.updateAvailable) {
                dialog.showMessageBox(mainWindow, {
                  type: 'info',
                  title: 'Update Available',
                  message: `Version ${result.version} is available`,
                  detail: 'Downloading update in the background. You will be prompted to restart when ready.',
                  buttons: ['OK']
                })
              } else {
                dialog.showMessageBox(mainWindow, {
                  type: 'info',
                  title: 'Up to Date',
                  message: 'You are using the latest version.',
                  buttons: ['OK']
                })
              }
            } else {
              dialog.showErrorBox('Update Check Failed', result.error || 'Could not check for updates.')
            }
          }
        },
        { type: 'separator' },
        { role: 'services' },
        { type: 'separator' },
        { role: 'hide' },
        { role: 'hideOthers' },
        { role: 'unhide' },
        { type: 'separator' },
        { role: 'quit' }
      ]
    }] : []),

    // File Menu
    {
      label: 'File',
      submenu: [
        isMac ? { role: 'close' } : { role: 'quit' }
      ]
    },

    // Edit Menu
    {
      label: 'Edit',
      submenu: [
        { role: 'undo' },
        { role: 'redo' },
        { type: 'separator' },
        { role: 'cut' },
        { role: 'copy' },
        { role: 'paste' },
        ...(isMac ? [
          { role: 'pasteAndMatchStyle' },
          { role: 'delete' },
          { role: 'selectAll' },
          { type: 'separator' },
          {
            label: 'Speech',
            submenu: [
              { role: 'startSpeaking' },
              { role: 'stopSpeaking' }
            ]
          }
        ] : [
          { role: 'delete' },
          { type: 'separator' },
          { role: 'selectAll' }
        ])
      ]
    },

    // View Menu
    {
      label: 'View',
      submenu: [
        { role: 'reload' },
        { role: 'forceReload' },
        { role: 'toggleDevTools' },
        { type: 'separator' },
        { role: 'resetZoom' },
        { role: 'zoomIn' },
        { role: 'zoomOut' },
        { type: 'separator' },
        { role: 'togglefullscreen' }
      ]
    },

    // Window Menu
    {
      label: 'Window',
      submenu: [
        { role: 'minimize' },
        { role: 'zoom' },
        ...(isMac ? [
          { type: 'separator' },
          { role: 'front' },
          { type: 'separator' },
          { role: 'window' }
        ] : [
          { role: 'close' }
        ])
      ]
    },

    // Help Menu
    {
      role: 'help',
      submenu: [
        {
          label: 'Palpable Website',
          click: async () => {
            await shell.openExternal('https://palpable.technology')
          }
        },
        {
          label: 'Download Latest Version',
          click: async () => {
            await checkForUpdates()
          }
        },
        { type: 'separator' },
        ...(!isMac ? [{
          label: 'Check for Updates...',
          click: async () => {
            const result = await checkForUpdates()
            if (result.success) {
              if (result.updateAvailable) {
                const { response } = await dialog.showMessageBox(mainWindow, {
                  type: 'info',
                  title: 'Update Available',
                  message: `Version ${result.version} is available`,
                  detail: 'Download and install the update now?',
                  buttons: ['Update', 'Later'],
                  defaultId: 0,
                  cancelId: 1
                })
                if (response === 0) {
                  try {
                    const { path: destPath, filename } = await downloadLatestUpdate()
                    await dialog.showMessageBox(mainWindow, {
                      type: 'info',
                      title: 'Update Ready',
                      message: `Downloaded ${filename}`,
                      detail: 'Open the installer to complete the update.',
                      buttons: ['Open', 'Show in Finder', 'Close'],
                      defaultId: 0,
                      cancelId: 2
                    }).then(({ response }) => {
                      if (response === 0) shell.openPath(destPath)
                      else if (response === 1) shell.showItemInFolder(destPath)
                    })
                  } catch (err) {
                    dialog.showErrorBox('Update Download Failed', err.message)
                  }
                }
              } else {
                dialog.showMessageBox(mainWindow, {
                  type: 'info',
                  title: 'Up to Date',
                  message: 'You are using the latest version.',
                  buttons: ['OK']
                })
              }
            } else {
              dialog.showErrorBox('Update Check Failed', result.error || 'Could not check for updates.')
            }
          }
        }] : [])
      ]
    }
  ]

  const menu = Menu.buildFromTemplate(template)
  Menu.setApplicationMenu(menu)
}

app.whenReady().then(() => {
  createWindow()
  createApplicationMenu()

  // Check for updates on launch (skip in dev mode)
  if (app.isPackaged && !process.argv.includes('--dev')) {
    checkForUpdates()
  }

  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow()
    }
  })
})

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit()
  }
})

// Handle custom protocol (OAuth callback)
app.on('open-url', (event, url) => {
  event.preventDefault()
  handleAuthCallback(url)
})

// For Windows: handle protocol in second-instance
app.on('second-instance', (event, argv) => {
  const url = argv.find(arg => arg.startsWith(`${PROTOCOL}://`))
  if (url) {
    handleAuthCallback(url)
  }
  if (mainWindow) {
    if (mainWindow.isMinimized()) mainWindow.restore()
    mainWindow.focus()
  }
})

function handleAuthCallback(url) {
  try {
    console.log('[Auth] Received callback URL:', url)
    const urlObj = new URL(url)
    const token = urlObj.searchParams.get('token')
    const userId = urlObj.searchParams.get('userId')

    console.log('[Auth] Parsed token:', token ? 'present' : 'missing')
    console.log('[Auth] Parsed userId:', userId || 'missing')

    if (token && userId) {
      store.set('authToken', token)
      store.set('userId', userId)
      console.log('[Auth] Credentials stored successfully')

      if (mainWindow) {
        mainWindow.webContents.send('auth-success', { token, userId })
        console.log('[Auth] Notified renderer of success')
      }

      if (authWindow) {
        authWindow.close()
        authWindow = null
      }
    } else {
      console.error('[Auth] Missing required parameters - token:', !!token, 'userId:', !!userId)
    }
  } catch (err) {
    console.error('[Auth] Failed to parse auth callback:', err)
  }
}

// ============================================
// IPC Handlers
// ============================================

// Get authentication state
ipcMain.handle('get-auth-state', () => {
  return {
    token: store.get('authToken'),
    userId: store.get('userId'),
    isAuthenticated: !!store.get('authToken')
  }
})

// Open browser for authentication
ipcMain.handle('start-auth', () => {
  const callbackUrl = `${PROTOCOL}://auth/callback`
  const authUrl = `${PALPABLE_AUTH_URL}?callback=${encodeURIComponent(callbackUrl)}`
  shell.openExternal(authUrl)
})

// Logout
ipcMain.handle('logout', () => {
  store.delete('authToken')
  store.delete('userId')
  return { success: true }
})

// List available drives
ipcMain.handle('list-drives', async () => {
  try {
    const drives = await drivelist.list()

    // Filter to only show SD cards and removable storage (not internal drives)
    return drives.filter(drive => {
      // Must have a size
      if (!drive.size || drive.size === 0) return false

      // STRICT: Must be removable AND not a system drive
      if (!drive.isRemovable) return false
      if (drive.isSystem) return false

      // STRICT: Exclude drives that are too large to be SD cards (max 1TB)
      // Most SD cards are 32GB-512GB, but allow up to 1TB to be safe
      const maxSize = 1024 * 1024 * 1024 * 1024 // 1TB in bytes
      if (drive.size > maxSize) return false

      // Platform-specific filtering
      if (process.platform === 'darwin') {
        const description = (drive.description || '').toLowerCase()
        const device = (drive.device || '').toLowerCase()

        // STRICT: Exclude disk images (they show up as removable on macOS)
        if (description.includes('disk image') ||
            description.includes('appleapfsmedia') ||
            description.includes('apple udif') ||
            description.includes('apple disk image') ||
            description.includes('synthesized')) {
          return false
        }

        // STRICT: Exclude internal drives (even if marked as removable)
        // Internal drives often have "internal" or "ssd" in description
        if (description.includes('internal') ||
            description.includes(' ssd') ||
            description.includes('apple ssd')) {
          return false
        }

        // PREFER: Drives explicitly marked as SD cards
        if (drive.isCard) return true

        // ALLOW: USB drives that could be SD card readers
        // Must be USB, removable, and have correct device pattern
        if (drive.isUSB) {
          // Device path should be /dev/disk* (not /dev/rdisk*)
          if (device.match(/^\/dev\/disk\d+$/)) {
            return true
          }
        }

        return false
      }

      if (process.platform === 'linux') {
        const description = (drive.description || '').toLowerCase()

        // STRICT: Exclude internal drives
        if (description.includes('internal')) return false

        // PREFER: Drives explicitly marked as SD cards
        if (drive.isCard) return true

        // ALLOW: USB drives that could be SD card readers
        if (drive.isUSB) return true

        return false
      }

      if (process.platform === 'win32') {
        const description = (drive.description || '').toLowerCase()

        // STRICT: Exclude internal drives
        if (description.includes('internal')) return false

        // PREFER: Drives explicitly marked as SD cards
        if (drive.isCard) return true

        // ALLOW: USB drives that could be SD card readers
        if (drive.isUSB) return true

        return false
      }

      return false
    }).map(drive => {
      // Try to get a friendly name from mountpoints (what Finder shows)
      let displayName = drive.description

      if (drive.mountpoints && drive.mountpoints.length > 0) {
        // Get the first mountpoint's label if available
        const mountpoint = drive.mountpoints[0]
        if (mountpoint.label) {
          displayName = mountpoint.label
        } else if (mountpoint.path) {
          // Extract volume name from path (e.g., /Volumes/MY_SD_CARD -> MY_SD_CARD)
          const volumeName = path.basename(mountpoint.path)
          if (volumeName && volumeName !== '/' && !volumeName.startsWith('disk')) {
            displayName = volumeName
          }
        }
      }

      return {
        device: drive.device,
        description: drive.description,
        displayName: displayName,
        size: drive.size,
        mountpoints: drive.mountpoints,
        isUSB: drive.isUSB,
        isCard: drive.isCard
      }
    })
  } catch (err) {
    console.error('Failed to list drives:', err)
    return []
  }
})

// Get download progress directory
const getDownloadPath = () => {
  const downloadDir = path.join(app.getPath('userData'), 'downloads')
  if (!fs.existsSync(downloadDir)) {
    fs.mkdirSync(downloadDir, { recursive: true })
  }
  return downloadDir
}

// Download Palpable OS image
ipcMain.handle('download-image', async (event) => {
  const downloadPath = getDownloadPath()
  const imagePath = path.join(downloadPath, 'palpable-os.img.xz')
  
  try {
    logEvent('Flash', 'Download start')
    // Check if we already have the latest image
    if (fs.existsSync(imagePath)) {
      const stats = fs.statSync(imagePath)
      // If downloaded within last 24 hours, use cached version
      const ageHours = (Date.now() - stats.mtimeMs) / (1000 * 60 * 60)
      if (ageHours < 24) {
        mainWindow.webContents.send('download-progress', { percent: 100, status: 'cached' })
        return { success: true, path: imagePath, cached: true }
      }
    }
    
    // Download the image
    const writeStream = fs.createWriteStream(imagePath)
    const downloadStream = got.stream(PALPABLE_OS_URL)
    
    let totalBytes = 0
    let downloadedBytes = 0
    
    downloadStream.on('response', (response) => {
      totalBytes = parseInt(response.headers['content-length'] || '0', 10)
      logEvent('Flash', 'Download response', { totalBytes })
    })
    
    downloadStream.on('downloadProgress', (progress) => {
      downloadedBytes = progress.transferred
      const percent = totalBytes > 0 ? Math.round((downloadedBytes / totalBytes) * 100) : 0
      mainWindow.webContents.send('download-progress', { 
        percent, 
        downloaded: downloadedBytes,
        total: totalBytes,
        status: 'downloading'
      })
      mainWindow.setProgressBar(percent / 100)
    })
    
    await new Promise((resolve, reject) => {
      downloadStream.pipe(writeStream)
      writeStream.on('finish', resolve)
      writeStream.on('error', reject)
      downloadStream.on('error', reject)
    })
    
    mainWindow.webContents.send('download-progress', { percent: 100, status: 'complete' })
    mainWindow.setProgressBar(-1)
    logEvent('Flash', 'Download complete', { path: imagePath })
    return { success: true, path: imagePath }
  } catch (err) {
    console.error('Download failed:', err)
    if (mainWindow) mainWindow.setProgressBar(-1)
    logEvent('Flash', 'Download failed', { error: err.message })
    return { success: false, error: err.message }
  }
})

// Flash image to drive
ipcMain.handle('flash-image', async (event, { imagePath, targetDevice }) => {
  try {
    logEvent('Flash', 'Flash start', { targetDevice, imagePath })
    // Confirm with user
    const { response } = await dialog.showMessageBox(mainWindow, {
      type: 'warning',
      buttons: ['Cancel', 'Flash'],
      defaultId: 0,
      cancelId: 0,
      title: 'Confirm Flash',
      message: `This will erase all data on ${targetDevice}`,
      detail: 'Make sure you have selected the correct drive. This action cannot be undone.'
    })
    
    if (response === 0) {
      return { success: false, cancelled: true }
    }
    
    mainWindow.webContents.send('flash-progress', { percent: 0, status: 'preparing' })
    
    // Decompress if needed
    let rawImagePath = imagePath
    if (imagePath.endsWith('.xz')) {
      rawImagePath = imagePath.replace('.xz', '')
      await decompressXZ(imagePath, rawImagePath, (percent) => {
        mainWindow.webContents.send('flash-progress', { 
          percent: Math.round(percent * 0.3), // 0-30% for decompression
          status: 'decompressing'
        })
        mainWindow.setProgressBar(percent / 100)
      })
      mainWindow.setProgressBar(-1)
    }
    
    mainWindow.webContents.send('flash-progress', { percent: 30, status: 'flashing' })
    
    // Flash the image using dd (requires sudo)
    await flashWithSudo(rawImagePath, targetDevice, (percent) => {
      mainWindow.webContents.send('flash-progress', { 
        percent: 30 + Math.round(percent * 0.7), // 30-100% for flashing
        status: 'flashing'
      })
      mainWindow.setProgressBar((30 + Math.round(percent * 0.7)) / 100)
    })
    
    mainWindow.webContents.send('flash-progress', { percent: 100, status: 'complete' })
    mainWindow.setProgressBar(-1)
    
    // Clean up decompressed image
    if (rawImagePath !== imagePath && fs.existsSync(rawImagePath)) {
      fs.unlinkSync(rawImagePath)
    }
    
    logEvent('Flash', 'Flash complete', { targetDevice })
    return { success: true }
  } catch (err) {
    console.error('Flash failed:', err)
    if (mainWindow) mainWindow.setProgressBar(-1)
    logEvent('Flash', 'Flash failed', { error: err.message })
    return { success: false, error: err.message }
  }
})

// Decompress XZ file using pure JavaScript (no system dependencies)
async function decompressXZ(inputPath, outputPath, onProgress) {
  return new Promise((resolve, reject) => {
    console.log(`Decompressing ${inputPath} to ${outputPath}`)

    const inputStream = fs.createReadStream(inputPath)
    const outputStream = fs.createWriteStream(outputPath)
    const decompressor = lzma.createDecompressor()

    let bytesProcessed = 0
    let totalBytes = 0

    // Get file size for progress tracking
    try {
      const stats = fs.statSync(inputPath)
      totalBytes = stats.size
    } catch (err) {
      console.warn('Could not get input file size:', err)
    }

    // Track progress
    inputStream.on('data', (chunk) => {
      bytesProcessed += chunk.length
      if (totalBytes > 0) {
        const progress = Math.floor((bytesProcessed / totalBytes) * 100)
        onProgress(progress)
      }
    })

    // Handle completion
    outputStream.on('finish', () => {
      onProgress(100)
      console.log('XZ decompression completed successfully')
      resolve()
    })

    // Handle errors
    const handleError = (err) => {
      console.error('XZ decompression error:', err)
      inputStream.destroy()
      outputStream.destroy()
      reject(new Error(`XZ decompression failed: ${err.message}`))
    }

    inputStream.on('error', handleError)
    decompressor.on('error', handleError)
    outputStream.on('error', handleError)

    // Pipe the streams together
    inputStream.pipe(decompressor).pipe(outputStream)
  })
}

// Flash image with sudo
async function flashWithSudo(imagePath, targetDevice, onProgress) {
  return new Promise((resolve, reject) => {
    // Normalize device path to the disk (not partition) and use raw device on macOS
    const platform = process.platform
    let device = targetDevice
    let command = ''

    if (platform === 'darwin') {
      // Strip partition suffix (e.g., disk2s1 -> disk2) and prefer raw device for speed/reliability
      device = device.replace(/s\d+$/, '')
      const rawDevice = device.replace('/dev/disk', '/dev/rdisk')
      command = `diskutil unmountDisk ${device} && dd if="${imagePath}" of=${rawDevice} bs=4m conv=sync status=progress`
    } else if (platform === 'linux') {
      // Strip partition suffix (e.g., /dev/sdb1 -> /dev/sdb)
      device = device.replace(/p?\d+$/, '')
      command = `umount ${device}* 2>/dev/null; dd if="${imagePath}" of=${device} bs=4M status=progress conv=fsync`
    } else {
      reject(new Error('Unsupported platform for flashing'))
      return
    }

    const options = { name: 'Palpable Imager' }

    sudo.exec(command, options, (error, stdout, stderr) => {
      if (error) {
        const msg = stderr || stdout || error.message || 'Flash failed'
        reject(new Error(msg))
      } else {
        onProgress(100)
        resolve()
      }
    })
    
    // Progress estimation
    let progress = 0
    const interval = setInterval(() => {
      if (progress < 95) {
        progress += 2
        onProgress(progress)
      }
    }, 1000)
    
    // Clear interval after typical flash time (will be overwritten by actual completion)
    setTimeout(() => clearInterval(interval), 300000) // 5 min max
  })
}

// Get user's devices
ipcMain.handle('get-devices', async () => {
  try {
    const token = store.get('authToken')
    
    if (!token) {
      return { success: false, devices: [] }
    }
    
    const response = await got.get(`${PALPABLE_API_URL}/devices`, {
      headers: { Authorization: `Bearer ${token}` },
      responseType: 'json'
    })
    
    return { 
      success: true, 
      devices: response.body.devices || []
    }
  } catch (err) {
    console.error('Failed to get devices:', err)
    return { success: false, devices: [], error: err.message }
  }
})

// Update device
ipcMain.handle('update-device', async (event, { deviceId, name, location, status }) => {
  try {
    const token = store.get('authToken')
    
    if (!token) {
      return { success: false, error: 'Not authenticated' }
    }
    
    const response = await got.patch(`${PALPABLE_API_URL}/devices/${deviceId}`, {
      json: { name, location, status },
      headers: { Authorization: `Bearer ${token}` },
      responseType: 'json'
    })
    
    return { 
      success: true, 
      device: response.body.device
    }
  } catch (err) {
    console.error('Failed to update device:', err)
    const errorMessage = err.response?.body?.error || err.message
    return { success: false, error: errorMessage }
  }
})

// Delete device
ipcMain.handle('delete-device', async (event, { deviceId }) => {
  try {
    const token = store.get('authToken')
    
    if (!token) {
      return { success: false, error: 'Not authenticated' }
    }
    
    const response = await got.delete(`${PALPABLE_API_URL}/devices/${deviceId}`, {
      headers: { Authorization: `Bearer ${token}` },
      responseType: 'json'
    })
    
    return { 
      success: true
    }
  } catch (err) {
    console.error('Failed to delete device:', err)
    const errorMessage = err.response?.body?.error || err.message
    return { success: false, error: errorMessage }
  }
})

// Register device with Palpable account (or re-flash existing)
ipcMain.handle('register-device', async (event, { deviceName, deviceId }) => {
  try {
    const token = store.get('authToken')
    const userId = store.get('userId')
    
    if (!token || !userId) {
      return { success: false, error: 'Not authenticated' }
    }
    
    const response = await got.post(`${PALPABLE_API_URL}/devices/register`, {
      json: { deviceName, userId, deviceId },
      headers: { Authorization: `Bearer ${token}` },
      responseType: 'json'
    })
    
    return { 
      success: true, 
      deviceId: response.body.deviceId,
      pairingCode: response.body.pairingCode
    }
  } catch (err) {
    console.error('Failed to register device:', err)
    return { success: false, error: err.message }
  }
})

// Get user's saved WiFi networks
ipcMain.handle('get-wifi-networks', async () => {
  try {
    const token = store.get('authToken')
    
    if (!token) {
      return { success: false, networks: [] }
    }
    
    const response = await got.get(`${PALPABLE_API_URL}/wifi`, {
      headers: { Authorization: `Bearer ${token}` },
      responseType: 'json'
    })
    
    return { success: true, networks: response.body.networks }
  } catch (err) {
    console.error('Failed to get WiFi networks:', err)
    return { success: false, networks: [], error: err.message }
  }
})

// ============================================
// PAIRING CODE AUTH (Alternative to Browser OAuth)
// ============================================

// Validate pairing code (check if valid without redeeming)
ipcMain.handle('validate-pairing-code', async (event, { pairingCode }) => {
  try {
    const response = await got.get(`${PALPABLE_API_URL}/devices/pair?code=${pairingCode}`, {
      responseType: 'json'
    })
    
    return response.body
  } catch (err) {
    console.error('Failed to validate pairing code:', err)
    return { valid: false, error: err.message }
  }
})

// Authenticate using pairing code
// This links the imager to an existing device with a pairing code
ipcMain.handle('auth-with-pairing-code', async (event, { pairingCode }) => {
  try {
    const response = await got.post(`${PALPABLE_API_URL}/devices/pair`, {
      json: { pairingCode },
      responseType: 'json'
    })
    
    if (response.body.success) {
      // Store device info for this session
      store.set('pairedDeviceId', response.body.deviceId)
      store.set('pairedDeviceName', response.body.deviceName)
      store.set('pairedUserId', response.body.userId)
      
      // Notify renderer of successful pairing
      if (mainWindow) {
        mainWindow.webContents.send('pairing-success', {
          deviceId: response.body.deviceId,
          deviceName: response.body.deviceName,
          userId: response.body.userId
        })
      }
      
      return { 
        success: true, 
        deviceId: response.body.deviceId,
        deviceName: response.body.deviceName
      }
    }
    
    return { success: false, error: response.body.error || 'Pairing failed' }
  } catch (err) {
    console.error('Failed to auth with pairing code:', err)
    const errorMessage = err.response?.body?.error || err.message
    return { success: false, error: errorMessage }
  }
})

// Get pairing state
ipcMain.handle('get-pairing-state', () => {
  return {
    deviceId: store.get('pairedDeviceId'),
    deviceName: store.get('pairedDeviceName'),
    userId: store.get('pairedUserId'),
    isPaired: !!store.get('pairedDeviceId')
  }
})

// Clear pairing (for re-flashing different device)
ipcMain.handle('clear-pairing', () => {
  store.delete('pairedDeviceId')
  store.delete('pairedDeviceName')
  store.delete('pairedUserId')
  return { success: true }
})

// ============================================
// AUTO-UPDATE (generic feed on Netlify)
// ============================================

function logEvent(scope, message, data) {
  const payload = data ? ` ${JSON.stringify(data)}` : ''
  console.log(`[${scope}] ${message}${payload}`)
}

async function checkForUpdates() {
  if (!app.isPackaged) {
    return { success: false, error: 'Updates are only available in packaged builds.' }
  }

  try {
    logEvent('Update', 'Checking for updates')
    const result = await autoUpdater.checkForUpdates()
    const info = result?.updateInfo
    const currentVersion = app.getVersion()
    const latestVersion = info?.version
    logEvent('Update', 'Versions', { currentVersion, latestVersion })

    if (info && latestVersion && latestVersion !== currentVersion) {
      logEvent('Update', 'Update available')
      return { success: true, updateAvailable: true, version: latestVersion }
    }

    logEvent('Update', 'Already up to date')
    return { success: true, updateAvailable: false, version: currentVersion }
  } catch (err) {
    logEvent('Update', 'Check failed', { error: err.message })
    return { success: false, error: err.message }
  }
}

// Manual check for updates (from renderer)
ipcMain.handle('check-for-updates', async () => {
  return await checkForUpdates()
})

// AutoUpdater events
if (app.isPackaged) {
  autoUpdater.on('update-available', (info) => {
    logEvent('Update', 'Update available event', { version: info?.version })
    if (mainWindow) {
      mainWindow.webContents.send('update-available', { version: info?.version })
    }
  })

  autoUpdater.on('update-not-available', (info) => {
    logEvent('Update', 'No update available', { version: info?.version })
    if (mainWindow) {
      mainWindow.webContents.send('update-not-available', { currentVersion: app.getVersion() })
    }
  })

  autoUpdater.on('download-progress', (progress) => {
    const percent = Math.round(progress.percent || 0)
    logEvent('Update', 'Download progress', { percent })
    if (mainWindow) {
      mainWindow.setProgressBar((progress.percent || 0) / 100)
      mainWindow.webContents.send('update-download-progress', { percent })
    }
  })

  autoUpdater.on('update-downloaded', (info) => {
    logEvent('Update', 'Update downloaded', { version: info?.version })
    if (mainWindow) {
      mainWindow.setProgressBar(-1)
      mainWindow.webContents.send('update-downloaded', { version: info?.version })
      dialog.showMessageBox(mainWindow, {
        type: 'info',
        title: 'Update Ready',
        message: `Palpable Imager ${info?.version || ''} downloaded`,
        detail: 'Restart now to install the update.',
        buttons: ['Restart', 'Later'],
        defaultId: 0,
        cancelId: 1
      }).then(({ response }) => {
        if (response === 0) {
          autoUpdater.quitAndInstall()
        }
      })
    }
  })

  autoUpdater.on('error', (err) => {
    logEvent('Update', 'Update error', { error: err.message })
    if (mainWindow) {
      mainWindow.setProgressBar(-1)
      dialog.showErrorBox('Update Error', err.message)
      mainWindow.webContents.send('update-error', { message: err.message })
    }
  })
}

// Get app version
ipcMain.handle('get-app-version', () => {
  return app.getVersion()
})

