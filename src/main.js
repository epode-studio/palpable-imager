const { app, BrowserWindow, ipcMain, shell, dialog, Menu } = require('electron')
const { autoUpdater } = require('electron-updater')
const path = require('path')
const { pipeline } = require('stream/promises')
const fs = require('fs')
const { spawn } = require('child_process')
const drivelist = require('drivelist')
const got = require('got')
const StreamZip = require('node-stream-zip')
const sudo = require('sudo-prompt')
const Store = require('electron-store')
const lzma = require('lzma-native')
const store = new Store()

// Configure auto-updater for public generic feed (generated by electron-builder publish)
autoUpdater.logger = console
autoUpdater.autoDownload = true

// For ad-hoc signed macOS apps, disable auto-install
// These apps can't pass signature verification, so we'll direct users to GitHub instead
if (process.platform === 'darwin') {
  autoUpdater.autoInstallOnAppQuit = false // Don't auto-install on macOS (ad-hoc signed)
  // Note: We'll manually direct users to GitHub releases when update is ready
} else {
  autoUpdater.autoInstallOnAppQuit = true // Auto-install on Windows/Linux
}

// Palpable API URLs
const PALPABLE_OS_REPO = 'epode-studio/palpable-os'
const PALPABLE_AUTH_URL = 'https://palpable.technology/auth/imager'
const PALPABLE_API_URL = 'https://palpable.technology/api'

let mainWindow = null
let authWindow = null
let downloadedUpdateInfo = null // Store update info for manual installation
let lastUpdateError = null // Track last update error to prevent duplicates
let lastUpdateErrorTime = 0 // Timestamp of last error

// Custom protocol for OAuth callback
const PROTOCOL = 'palpable-imager'

function createWindow() {
  mainWindow = new BrowserWindow({
    width: 800,
    height: 600,
    minWidth: 600,
    minHeight: 500,
    backgroundColor: '#0a0a0a',
    titleBarStyle: 'hiddenInset',
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js')
    },
    icon: path.join(__dirname, '../assets/icon.png')
  })

  mainWindow.loadFile(path.join(__dirname, 'index.html'))

  // Open DevTools in development
  if (process.argv.includes('--dev')) {
    mainWindow.webContents.openDevTools()
  }
}

// Register custom protocol for OAuth callback
app.setAsDefaultProtocolClient(PROTOCOL)

// Create application menu
function createApplicationMenu() {
  const isMac = process.platform === 'darwin'

  const template = [
    // App Menu (macOS only)
    ...(isMac ? [{
      label: app.name,
      submenu: [
        { role: 'about' },
        { type: 'separator' },
        {
          label: 'Check for Updates...',
          click: async () => {
            const result = await checkForUpdates()
            if (result.success) {
              if (result.updateAvailable) {
                dialog.showMessageBox(mainWindow, {
                  type: 'info',
                  title: 'Update Available',
                  message: `Version ${result.version} is available`,
                  detail: 'Downloading update in the background. You will be prompted to restart when ready.',
                  buttons: ['OK']
                })
              } else {
                dialog.showMessageBox(mainWindow, {
                  type: 'info',
                  title: 'Up to Date',
                  message: 'You are using the latest version.',
                  buttons: ['OK']
                })
              }
            } else {
              dialog.showErrorBox('Update Check Failed', result.error || 'Could not check for updates.')
            }
          }
        },
        { type: 'separator' },
        { role: 'services' },
        { type: 'separator' },
        { role: 'hide' },
        { role: 'hideOthers' },
        { role: 'unhide' },
        { type: 'separator' },
        { role: 'quit' }
      ]
    }] : []),

    // File Menu
    {
      label: 'File',
      submenu: [
        isMac ? { role: 'close' } : { role: 'quit' }
      ]
    },

    // Account Menu
    {
      label: 'Account',
      submenu: [
        {
          label: 'Sign Out',
          click: async () => {
            const { response } = await dialog.showMessageBox(mainWindow, {
              type: 'question',
              title: 'Sign Out',
              message: 'Are you sure you want to sign out?',
              detail: 'You will need to sign in again to manage your devices.',
              buttons: ['Sign Out', 'Cancel'],
              defaultId: 1,
              cancelId: 1
            })
            if (response === 0) {
              store.delete('authToken')
              store.delete('refreshToken')
              store.delete('userId')
              if (mainWindow) {
                mainWindow.webContents.send('auth-logout')
              }
            }
          }
        }
      ]
    },

    // Edit Menu
    {
      label: 'Edit',
      submenu: [
        { role: 'undo' },
        { role: 'redo' },
        { type: 'separator' },
        { role: 'cut' },
        { role: 'copy' },
        { role: 'paste' },
        ...(isMac ? [
          { role: 'pasteAndMatchStyle' },
          { role: 'delete' },
          { role: 'selectAll' },
          { type: 'separator' },
          {
            label: 'Speech',
            submenu: [
              { role: 'startSpeaking' },
              { role: 'stopSpeaking' }
            ]
          }
        ] : [
          { role: 'delete' },
          { type: 'separator' },
          { role: 'selectAll' }
        ])
      ]
    },

    // View Menu
    {
      label: 'View',
      submenu: [
        { role: 'reload' },
        { role: 'forceReload' },
        { role: 'toggleDevTools' },
        { type: 'separator' },
        { role: 'resetZoom' },
        { role: 'zoomIn' },
        { role: 'zoomOut' },
        { type: 'separator' },
        { role: 'togglefullscreen' }
      ]
    },

    // Window Menu
    {
      label: 'Window',
      submenu: [
        { role: 'minimize' },
        { role: 'zoom' },
        ...(isMac ? [
          { type: 'separator' },
          { role: 'front' },
          { type: 'separator' },
          { role: 'window' }
        ] : [
          { role: 'close' }
        ])
      ]
    },

    // Help Menu
    {
      role: 'help',
      submenu: [
        {
          label: 'Palpable Website',
          click: async () => {
            await shell.openExternal('https://palpable.technology')
          }
        },
        {
          label: 'Download Latest Version',
          click: async () => {
            await checkForUpdates()
          }
        },
        { type: 'separator' },
        ...(!isMac ? [{
          label: 'Check for Updates...',
          click: async () => {
            const result = await checkForUpdates()
            if (result.success) {
              if (result.updateAvailable) {
                const { response } = await dialog.showMessageBox(mainWindow, {
                  type: 'info',
                  title: 'Update Available',
                  message: `Version ${result.version} is available`,
                  detail: 'Download and install the update now?',
                  buttons: ['Update', 'Later'],
                  defaultId: 0,
                  cancelId: 1
                })
                if (response === 0) {
                  try {
                    const { path: destPath, filename } = await downloadLatestUpdate()
                    await dialog.showMessageBox(mainWindow, {
                      type: 'info',
                      title: 'Update Ready',
                      message: `Downloaded ${filename}`,
                      detail: 'Open the installer to complete the update.',
                      buttons: ['Open', 'Show in Finder', 'Close'],
                      defaultId: 0,
                      cancelId: 2
                    }).then(({ response }) => {
                      if (response === 0) shell.openPath(destPath)
                      else if (response === 1) shell.showItemInFolder(destPath)
                    })
                  } catch (err) {
                    dialog.showErrorBox('Update Download Failed', err.message)
                  }
                }
              } else {
                dialog.showMessageBox(mainWindow, {
                  type: 'info',
                  title: 'Up to Date',
                  message: 'You are using the latest version.',
                  buttons: ['OK']
                })
              }
            } else {
              dialog.showErrorBox('Update Check Failed', result.error || 'Could not check for updates.')
            }
          }
        }] : [])
      ]
    }
  ]

  const menu = Menu.buildFromTemplate(template)
  Menu.setApplicationMenu(menu)
}

app.whenReady().then(() => {
  createWindow()
  createApplicationMenu()

  // Check for updates on launch (skip in dev mode)
  if (app.isPackaged && !process.argv.includes('--dev')) {
    checkForUpdates()
  }

  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow()
    }
  })
})

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit()
  }
})

// Handle custom protocol (OAuth callback)
app.on('open-url', (event, url) => {
  event.preventDefault()
  handleAuthCallback(url)
})

// For Windows: handle protocol in second-instance
app.on('second-instance', (event, argv) => {
  const url = argv.find(arg => arg.startsWith(`${PROTOCOL}://`))
  if (url) {
    handleAuthCallback(url)
  }
  if (mainWindow) {
    if (mainWindow.isMinimized()) mainWindow.restore()
    mainWindow.focus()
  }
})

function handleAuthCallback(url) {
  try {
    console.log('[Auth] Received callback URL:', url)
    const urlObj = new URL(url)
    const token = urlObj.searchParams.get('token')
    const userId = urlObj.searchParams.get('userId')
    const refreshToken = urlObj.searchParams.get('refreshToken')

    console.log('[Auth] Parsed token:', token ? 'present' : 'missing')
    console.log('[Auth] Parsed userId:', userId || 'missing')
    console.log('[Auth] Parsed refreshToken:', refreshToken ? 'present' : 'missing')

    if (token && userId) {
      store.set('authToken', token)
      store.set('userId', userId)
      if (refreshToken) {
        store.set('refreshToken', refreshToken)
      }
      console.log('[Auth] Credentials stored successfully')

      if (mainWindow) {
        mainWindow.webContents.send('auth-success', { token, userId })
        console.log('[Auth] Notified renderer of success')
      }

      if (authWindow) {
        authWindow.close()
        authWindow = null
      }
    } else {
      console.error('[Auth] Missing required parameters - token:', !!token, 'userId:', !!userId)
    }
  } catch (err) {
    console.error('[Auth] Failed to parse auth callback:', err)
  }
}

// Refresh access token using refresh token
async function refreshAccessToken() {
  const refreshToken = store.get('refreshToken')
  if (!refreshToken) {
    console.log('[Auth] No refresh token available')
    return null
  }

  try {
    console.log('[Auth] Attempting to refresh access token...')
    const response = await got.post(`${PALPABLE_API_URL}/auth/refresh`, {
      json: { refreshToken },
      responseType: 'json'
    })

    const { accessToken, refreshToken: newRefreshToken } = response.body

    if (accessToken) {
      store.set('authToken', accessToken)
      if (newRefreshToken) {
        store.set('refreshToken', newRefreshToken)
      }
      console.log('[Auth] Token refreshed successfully')
      return accessToken
    }
  } catch (err) {
    console.error('[Auth] Failed to refresh token:', err.message)
    // If refresh fails with 401, clear all auth data
    if (err.response?.statusCode === 401) {
      store.delete('authToken')
      store.delete('refreshToken')
      store.delete('userId')
    }
  }
  return null
}

// Get valid auth token, refreshing if needed
async function getValidToken() {
  const token = store.get('authToken')
  if (!token) return null

  // Check if token is expired (JWT exp claim)
  try {
    const payload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString())
    const expiresAt = payload.exp * 1000 // Convert to milliseconds
    const now = Date.now()

    // If token expires in less than 5 minutes, refresh it
    if (expiresAt - now < 5 * 60 * 1000) {
      console.log('[Auth] Token expiring soon, attempting refresh...')
      const newToken = await refreshAccessToken()
      return newToken || token // Return old token if refresh fails
    }
  } catch (err) {
    console.error('[Auth] Error checking token expiration:', err)
  }

  return token
}

// ============================================
// IPC Handlers
// ============================================

// Get authentication state
ipcMain.handle('get-auth-state', () => {
  return {
    token: store.get('authToken'),
    userId: store.get('userId'),
    isAuthenticated: !!store.get('authToken')
  }
})

// Open browser for authentication
ipcMain.handle('start-auth', () => {
  const callbackUrl = `${PROTOCOL}://auth/callback`
  const authUrl = `${PALPABLE_AUTH_URL}?callback=${encodeURIComponent(callbackUrl)}`
  shell.openExternal(authUrl)
})

// Logout
ipcMain.handle('logout', () => {
  store.delete('authToken')
  store.delete('refreshToken')
  store.delete('userId')
  return { success: true }
})

// List available drives
ipcMain.handle('list-drives', async () => {
  try {
    const drives = await drivelist.list()

    // Filter to only show SD cards and removable storage (not internal drives)
    return drives.filter(drive => {
      // Must have a size
      if (!drive.size || drive.size === 0) return false

      // STRICT: Must be removable AND not a system drive
      if (!drive.isRemovable) return false
      if (drive.isSystem) return false

      // STRICT: Exclude drives that are too large to be SD cards (max 1TB)
      // Most SD cards are 32GB-512GB, but allow up to 1TB to be safe
      const maxSize = 1024 * 1024 * 1024 * 1024 // 1TB in bytes
      if (drive.size > maxSize) return false

      // Platform-specific filtering
      if (process.platform === 'darwin') {
        const description = (drive.description || '').toLowerCase()
        const device = (drive.device || '').toLowerCase()

        // STRICT: Exclude disk images (they show up as removable on macOS)
        if (description.includes('disk image') ||
            description.includes('appleapfsmedia') ||
            description.includes('apple udif') ||
            description.includes('apple disk image') ||
            description.includes('synthesized')) {
          return false
        }

        // STRICT: Exclude internal drives (even if marked as removable)
        // Internal drives often have "internal" or "ssd" in description
        if (description.includes('internal') ||
            description.includes(' ssd') ||
            description.includes('apple ssd')) {
          return false
        }

        // PREFER: Drives explicitly marked as SD cards
        if (drive.isCard) return true

        // ALLOW: Card readers (including Apple SDXC readers)
        // These might not be marked as USB or Card by drivelist
        if (description.includes('card reader') ||
            description.includes('sdxc') ||
            description.includes('sd card') ||
            description.includes('mmc')) {
          // Must have valid device path
          if (device.match(/^\/dev\/disk\d+$/)) {
            return true
          }
        }

        // ALLOW: USB drives that could be SD card readers
        // Must be USB, removable, and have correct device pattern
        if (drive.isUSB) {
          // Device path should be /dev/disk* (not /dev/rdisk*)
          if (device.match(/^\/dev\/disk\d+$/)) {
            return true
          }
        }

        return false
      }

      if (process.platform === 'linux') {
        const description = (drive.description || '').toLowerCase()

        // STRICT: Exclude internal drives
        if (description.includes('internal')) return false

        // PREFER: Drives explicitly marked as SD cards
        if (drive.isCard) return true

        // ALLOW: USB drives that could be SD card readers
        if (drive.isUSB) return true

        return false
      }

      if (process.platform === 'win32') {
        const description = (drive.description || '').toLowerCase()

        // STRICT: Exclude internal drives
        if (description.includes('internal')) return false

        // PREFER: Drives explicitly marked as SD cards
        if (drive.isCard) return true

        // ALLOW: USB drives that could be SD card readers
        if (drive.isUSB) return true

        return false
      }

      return false
    }).map(drive => {
      // Try to get a friendly name from mountpoints (what Finder shows)
      let displayName = drive.description
      let volumeLabel = ''

      if (drive.mountpoints && drive.mountpoints.length > 0) {
        // Get the first mountpoint's label if available
        const mountpoint = drive.mountpoints[0]
        if (mountpoint.label && mountpoint.label.trim() !== '') {
          volumeLabel = mountpoint.label.trim()
          // For SD cards, prefer showing the volume label prominently
          if (drive.isCard) {
            displayName = volumeLabel
          } else {
            displayName = `${volumeLabel} (${drive.description})`
          }
        } else if (mountpoint.path) {
          // Extract volume name from path (e.g., /Volumes/MY_SD_CARD -> MY_SD_CARD)
          const volumeName = path.basename(mountpoint.path)
          if (volumeName && volumeName !== '/' && !volumeName.startsWith('disk')) {
            volumeLabel = volumeName
            if (drive.isCard) {
              displayName = volumeName
            } else {
              displayName = `${volumeName} (${drive.description})`
            }
          }
        }
      }

      // If no friendly name found but it's a card, at least indicate it's an SD card
      if (drive.isCard && displayName === drive.description) {
        displayName = 'SD Card'
      }

      return {
        device: drive.device,
        description: drive.description,
        displayName: displayName,
        size: drive.size,
        mountpoints: drive.mountpoints,
        isUSB: drive.isUSB,
        isCard: drive.isCard
      }
    })
  } catch (err) {
    console.error('Failed to list drives:', err)
    return []
  }
})

// Get download progress directory
const getDownloadPath = () => {
  const downloadDir = path.join(app.getPath('userData'), 'downloads')
  if (!fs.existsSync(downloadDir)) {
    fs.mkdirSync(downloadDir, { recursive: true })
  }
  return downloadDir
}

// Download Palpable OS image from GitHub releases
ipcMain.handle('download-image', async (event) => {
  const downloadPath = getDownloadPath()
  const imagePath = path.join(downloadPath, 'palpable-os.img.xz')
  
  try {
    logEvent('Flash', 'Download start')
    // Check if we already have the latest image
    if (fs.existsSync(imagePath)) {
      const stats = fs.statSync(imagePath)
      
      // Verify cached file is valid
      let isValid = true
      if (stats.size === 0) {
        isValid = false
        logEvent('Flash', 'Cached file is empty, will re-download')
      } else if (imagePath.endsWith('.xz')) {
        // Verify XZ magic bytes
        try {
          const fd = fs.openSync(imagePath, 'r')
          const buffer = Buffer.alloc(6)
          fs.readSync(fd, buffer, 0, 6, 0)
          fs.closeSync(fd)
          const xzMagic = Buffer.from([0xFD, 0x37, 0x7A, 0x58, 0x5A, 0x00])
          if (!buffer.equals(xzMagic)) {
            isValid = false
            logEvent('Flash', 'Cached file is not a valid XZ file, will re-download')
          }
        } catch (err) {
          isValid = false
          logEvent('Flash', 'Cannot verify cached file, will re-download', { error: err.message })
        }
      }
      
      // If cached file is invalid, delete it
      if (!isValid) {
        try {
          fs.unlinkSync(imagePath)
          logEvent('Flash', 'Deleted corrupted cached file')
        } catch (err) {
          console.warn('Failed to delete corrupted cached file:', err)
        }
      } else {
        // If downloaded within last 24 hours and valid, use cached version
        const ageHours = (Date.now() - stats.mtimeMs) / (1000 * 60 * 60)
        if (ageHours < 24) {
          mainWindow.webContents.send('download-progress', { percent: 100, status: 'cached' })
          return { success: true, path: imagePath, cached: true }
        }
      }
    }
    
    // Step 1: Get the latest release from GitHub
    mainWindow.webContents.send('download-progress', { percent: 0, status: 'checking' })
    logEvent('Flash', 'Fetching latest release from GitHub', { repo: PALPABLE_OS_REPO })
    
    const releaseResponse = await got.get(`https://api.github.com/repos/${PALPABLE_OS_REPO}/releases/latest`, {
      responseType: 'json',
      headers: {
        'User-Agent': 'Palpable-Imager',
        'Accept': 'application/vnd.github.v3+json'
      }
    })
    
    const release = releaseResponse.body
    logEvent('Flash', 'Latest release found', { tag: release.tag_name, assets: release.assets.length })
    
    // Step 2: Find the image file in release assets
    // Look for .img.xz file (compressed image) - prefer .img.xz over just .xz
    let imageAsset = release.assets.find(asset => asset.name.endsWith('.img.xz'))
    if (!imageAsset) {
      imageAsset = release.assets.find(asset => asset.name.endsWith('.xz'))
    }
    
    if (!imageAsset) {
      const availableAssets = release.assets.map(a => a.name).join(', ')
      logEvent('Flash', 'No XZ image found', { availableAssets, releaseTag: release.tag_name })
      throw new Error(`No XZ image file found in release ${release.tag_name}. Available files: ${availableAssets || 'none'}`)
    }
    
    logEvent('Flash', 'Image asset found', { 
      name: imageAsset.name, 
      size: imageAsset.size, 
      contentType: imageAsset.content_type,
      url: imageAsset.browser_download_url 
    })
    
    // Warn if file seems suspiciously small (might be corrupted)
    if (imageAsset.size && imageAsset.size < 1000000) { // Less than 1MB
      logEvent('Flash', 'Warning: Image file seems unusually small', { size: imageAsset.size })
    }
    
    // Step 3: Download the image file
    mainWindow.webContents.send('download-progress', { percent: 5, status: 'downloading' })
    
    const writeStream = fs.createWriteStream(imagePath)
    const downloadStream = got.stream(imageAsset.browser_download_url, {
      headers: {
        'User-Agent': 'Palpable-Imager',
        'Accept': 'application/octet-stream'
      }
    })
    
    let totalBytes = imageAsset.size || 0
    let downloadedBytes = 0
    
    downloadStream.on('response', (response) => {
      // Check status code
      if (response.statusCode < 200 || response.statusCode >= 300) {
        const error = new Error(`Download failed: Server returned ${response.statusCode} ${response.statusMessage || ''}`)
        error.statusCode = response.statusCode
        downloadStream.destroy()
        writeStream.destroy()
        downloadStream.emit('error', error)
        return
      }
      // Use content-length from response if available, otherwise use asset size
      if (response.headers['content-length']) {
        totalBytes = parseInt(response.headers['content-length'], 10)
      }
      logEvent('Flash', 'Download response', { totalBytes, statusCode: response.statusCode })
    })
    
    downloadStream.on('downloadProgress', (progress) => {
      downloadedBytes = progress.transferred
      const percent = totalBytes > 0 ? Math.round(5 + (downloadedBytes / totalBytes) * 95) : 0 // 5-100% for download
      mainWindow.webContents.send('download-progress', { 
        percent, 
        downloaded: downloadedBytes,
        total: totalBytes,
        status: 'downloading'
      })
      mainWindow.setProgressBar(percent / 100)
    })
    
    await new Promise((resolve, reject) => {
      downloadStream.pipe(writeStream)
      writeStream.on('finish', resolve)
      writeStream.on('error', reject)
      downloadStream.on('error', (err) => {
        // Provide better error messages for HTTP errors
        if (err.response) {
          const statusCode = err.response.statusCode
          if (statusCode === 404) {
            reject(new Error(`Palpable OS image not found in release. Please check the GitHub repository for available releases.`))
          } else if (statusCode === 403) {
            reject(new Error(`Rate limit exceeded. Please wait a moment and try again.`))
          } else {
            reject(new Error(`Download failed: Server returned ${statusCode} ${err.response.statusMessage || ''}`))
          }
        } else if (err.statusCode) {
          if (err.statusCode === 404) {
            reject(new Error(`Palpable OS image not found in release. Please check the GitHub repository for available releases.`))
          } else if (err.statusCode === 403) {
            reject(new Error(`Rate limit exceeded. Please wait a moment and try again.`))
          } else {
            reject(err)
          }
        } else {
          reject(err)
        }
      })
    })
    
    mainWindow.webContents.send('download-progress', { percent: 100, status: 'complete' })
    mainWindow.setProgressBar(-1)
    
    // Verify downloaded file is valid
    try {
      const stats = fs.statSync(imagePath)
      logEvent('Flash', 'Downloaded file stats', { 
        size: stats.size, 
        expectedSize: imageAsset.size,
        match: stats.size === imageAsset.size 
      })
      
      if (stats.size === 0) {
        fs.unlinkSync(imagePath)
        throw new Error('Downloaded file is empty. The file in the GitHub release may be corrupted. Please check the palpable-os repository.')
      }
      
      // Check if download size matches expected size (allow small differences for metadata)
      if (imageAsset.size && Math.abs(stats.size - imageAsset.size) > 1000) {
        logEvent('Flash', 'Warning: Downloaded size does not match expected size', {
          downloaded: stats.size,
          expected: imageAsset.size,
          difference: Math.abs(stats.size - imageAsset.size)
        })
      }
      
      // Verify XZ magic bytes if it's an XZ file
      if (imagePath.endsWith('.xz')) {
        const fd = fs.openSync(imagePath, 'r')
        const buffer = Buffer.alloc(6)
        fs.readSync(fd, buffer, 0, 6, 0)
        fs.closeSync(fd)
        const xzMagic = Buffer.from([0xFD, 0x37, 0x7A, 0x58, 0x5A, 0x00])
        const hexHeader = Array.from(buffer).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ')
        logEvent('Flash', 'XZ file header check', { header: hexHeader })
        
        if (!buffer.equals(xzMagic)) {
          fs.unlinkSync(imagePath)
          throw new Error(`Downloaded file is not a valid XZ file. File header: ${hexHeader}. The file in the GitHub release (${release.tag_name}) may be corrupted or in the wrong format. Please check the palpable-os repository: https://github.com/${PALPABLE_OS_REPO}/releases`)
        }
        logEvent('Flash', 'XZ file header validated successfully')
      }
      logEvent('Flash', 'Download complete and validated', { path: imagePath, version: release.tag_name, size: stats.size })
    } catch (err) {
      if (fs.existsSync(imagePath)) {
        fs.unlinkSync(imagePath)
      }
      throw err
    }
    
    return { success: true, path: imagePath, version: release.tag_name }
  } catch (err) {
    console.error('Download failed:', err)
    if (mainWindow) mainWindow.setProgressBar(-1)
    
    // Extract better error message
    let errorMessage = err.message
    if (err.response) {
      const statusCode = err.response.statusCode
      if (statusCode === 404) {
        errorMessage = `Palpable OS release not found. Please check if the repository exists and has releases available.`
      } else if (statusCode === 403) {
        errorMessage = `GitHub rate limit exceeded. Please wait a moment and try again.`
      } else {
        errorMessage = `Download failed: Server returned ${statusCode} ${err.response.statusMessage || ''}`
      }
    } else if (err.code === 'ENOTFOUND' || err.code === 'ECONNREFUSED') {
      errorMessage = `Cannot connect to GitHub. Please check your internet connection.`
    }
    
    logEvent('Flash', 'Download failed', { error: errorMessage, originalError: err.message })
    return { success: false, error: errorMessage }
  }
})

// Flash image to drive
ipcMain.handle('flash-image', async (event, { imagePath, targetDevice, deviceId, deviceName, pairingCode }) => {
  try {
    // Validate required parameters
    if (!targetDevice) {
      return { success: false, error: 'No target drive selected. Please select a drive and try again.' }
    }
    if (!imagePath) {
      return { success: false, error: 'No image path provided. Please try again.' }
    }

    logEvent('Flash', 'Flash start', { targetDevice, imagePath, deviceId })
    // Confirm with user
    const { response } = await dialog.showMessageBox(mainWindow, {
      type: 'warning',
      buttons: ['Cancel', 'Flash'],
      defaultId: 0,
      cancelId: 0,
      title: 'Confirm Flash',
      message: `This will erase all data on ${targetDevice}`,
      detail: 'Make sure you have selected the correct drive. This action cannot be undone.'
    })
    
    if (response === 0) {
      return { success: false, cancelled: true }
    }
    
    mainWindow.webContents.send('flash-progress', { percent: 0, status: 'preparing' })
    
    // Decompress if needed
    let rawImagePath = imagePath
    if (imagePath.endsWith('.xz')) {
      rawImagePath = imagePath.replace('.xz', '')
      
      // Verify file exists and is readable before decompression
      if (!fs.existsSync(imagePath)) {
        throw new Error('Image file not found. Please download it again.')
      }
      
      try {
        await decompressXZ(imagePath, rawImagePath, (percent) => {
          mainWindow.webContents.send('flash-progress', { 
            percent: Math.round(percent * 0.3), // 0-30% for decompression
            status: 'decompressing'
          })
          mainWindow.setProgressBar(percent / 100)
        })
        mainWindow.setProgressBar(-1)
        
        // Verify decompressed file exists and has content
        if (!fs.existsSync(rawImagePath)) {
          throw new Error('Decompression completed but output file was not created.')
        }
        const decompressedStats = fs.statSync(rawImagePath)
        if (decompressedStats.size === 0) {
          fs.unlinkSync(rawImagePath)
          throw new Error('Decompressed file is empty. The source file may be corrupted.')
        }
        logEvent('Flash', 'Decompression complete', { outputSize: decompressedStats.size })
      } catch (err) {
        // Clean up partial decompressed file on error
        if (fs.existsSync(rawImagePath)) {
          try {
            fs.unlinkSync(rawImagePath)
          } catch (cleanupErr) {
            console.warn('Failed to clean up partial decompressed file:', cleanupErr)
          }
        }
        throw err
      }
    }
    
    mainWindow.webContents.send('flash-progress', { percent: 30, status: 'flashing' })
    
    // Flash the image using dd (requires sudo)
    await flashWithSudo(rawImagePath, targetDevice, (percent) => {
      mainWindow.webContents.send('flash-progress', { 
        percent: 30 + Math.round(percent * 0.7), // 30-100% for flashing
        status: 'flashing'
      })
      mainWindow.setProgressBar((30 + Math.round(percent * 0.7)) / 100)
    })
    
    mainWindow.webContents.send('flash-progress', { percent: 95, status: 'configuring' })

    // Write device config to boot partition (after flash remounts)
    if (deviceId) {
      try {
        await writeDeviceConfig(targetDevice, { deviceId, deviceName, pairingCode })
        logEvent('Flash', 'Device config written', { deviceId })
      } catch (configErr) {
        console.warn('Failed to write device config:', configErr)
        // Don't fail the flash, just warn - user can add config manually
      }
    }

    mainWindow.webContents.send('flash-progress', { percent: 100, status: 'complete' })
    mainWindow.setProgressBar(-1)

    // Clean up decompressed image
    if (rawImagePath !== imagePath && fs.existsSync(rawImagePath)) {
      fs.unlinkSync(rawImagePath)
    }

    logEvent('Flash', 'Flash complete', { targetDevice })
    return { success: true }
  } catch (err) {
    console.error('Flash failed:', err)
    if (mainWindow) mainWindow.setProgressBar(-1)
    logEvent('Flash', 'Flash failed', { error: err.message })
    return { success: false, error: err.message }
  }
})

// Decompress XZ file using pure JavaScript (no system dependencies)
async function decompressXZ(inputPath, outputPath, onProgress) {
  return new Promise((resolve, reject) => {
    console.log(`Decompressing ${inputPath} to ${outputPath}`)

    // Verify input file exists and has content
    try {
      const stats = fs.statSync(inputPath)
      if (stats.size === 0) {
        reject(new Error('XZ file is empty. The download may have failed. Please try again.'))
        return
      }
      if (stats.size < 100) {
        reject(new Error('XZ file is too small to be valid. The download may be incomplete. Please try again.'))
        return
      }
      console.log(`Input file size: ${stats.size} bytes`)
    } catch (err) {
      reject(new Error(`Cannot access XZ file: ${err.message}`))
      return
    }

    // Verify it's actually an XZ file by checking magic bytes
    const fd = fs.openSync(inputPath, 'r')
    const buffer = Buffer.alloc(6)
    try {
      fs.readSync(fd, buffer, 0, 6, 0)
      fs.closeSync(fd)
      // XZ files start with magic bytes: FD 37 7A 58 5A 00
      const xzMagic = Buffer.from([0xFD, 0x37, 0x7A, 0x58, 0x5A, 0x00])
      if (!buffer.equals(xzMagic)) {
        reject(new Error('File does not appear to be a valid XZ file. The download may be corrupted. Please try downloading again.'))
        return
      }
    } catch (err) {
      fs.closeSync(fd)
      reject(new Error(`Cannot read XZ file header: ${err.message}`))
      return
    }

    const inputStream = fs.createReadStream(inputPath)
    const outputStream = fs.createWriteStream(outputPath)
    
    // Create decompressor with error handling
    let decompressor
    try {
      decompressor = lzma.createDecompressor()
    } catch (err) {
      inputStream.destroy()
      outputStream.destroy()
      reject(new Error(`Failed to create XZ decompressor: ${err.message}`))
      return
    }

    let bytesProcessed = 0
    let totalBytes = 0
    let outputBytes = 0

    // Get file size for progress tracking
    try {
      const stats = fs.statSync(inputPath)
      totalBytes = stats.size
    } catch (err) {
      console.warn('Could not get input file size:', err)
    }

    // Track input progress (compressed bytes read)
    inputStream.on('data', (chunk) => {
      bytesProcessed += chunk.length
      if (totalBytes > 0) {
        // Use input progress as approximation (XZ compression ratio varies)
        const progress = Math.min(95, Math.floor((bytesProcessed / totalBytes) * 100))
        onProgress(progress)
      }
    })

    // Track output progress (decompressed bytes written)
    outputStream.on('drain', () => {
      // Output stream is keeping up
    })

    // Handle completion
    outputStream.on('finish', () => {
      onProgress(100)
      console.log('XZ decompression completed successfully')
      resolve()
    })

    // Handle errors with better messages
    const handleError = (err) => {
      console.error('XZ decompression error:', err)
      inputStream.destroy()
      if (decompressor && typeof decompressor.destroy === 'function') {
        decompressor.destroy()
      }
      outputStream.destroy()
      
      let errorMessage = `XZ decompression failed: ${err.message}`
      
      // Provide more helpful error messages
      if (err.message.includes('No progress is possible') || err.message.includes('progress')) {
        errorMessage = `XZ file appears to be corrupted or incomplete. This may indicate the file in the palpable-os GitHub release is corrupted. Please check https://github.com/${PALPABLE_OS_REPO}/releases and verify the file is valid. You can also try deleting the cached file and downloading again.`
      } else if (err.message.includes('unexpected end of file') || err.message.includes('truncated')) {
        errorMessage = `XZ file is incomplete. The download may have been interrupted, or the file in the palpable-os release may be corrupted. Please check https://github.com/${PALPABLE_OS_REPO}/releases and try downloading again.`
      } else if (err.message.includes('format') || err.message.includes('invalid')) {
        errorMessage = `File is not a valid XZ format. The file in the palpable-os GitHub release may be in the wrong format. Please check https://github.com/${PALPABLE_OS_REPO}/releases`
      }
      
      reject(new Error(errorMessage))
    }

    inputStream.on('error', handleError)
    decompressor.on('error', handleError)
    outputStream.on('error', handleError)

    // Pipe the streams together
    inputStream.pipe(decompressor).pipe(outputStream)
  })
}

// Write device config to boot partition after flashing
async function writeDeviceConfig(targetDevice, { deviceId, deviceName, pairingCode }) {
  const platform = process.platform

  if (platform === 'darwin') {
    // macOS: remount the disk and find the boot partition
    const { execSync, spawn } = require('child_process')

    // Get the base disk (e.g., /dev/disk2 from /dev/disk2s1)
    const baseDisk = targetDevice.replace(/s\d+$/, '')

    // Mount the disk
    console.log('[Config] Mounting disk:', baseDisk)
    try {
      execSync(`diskutil mountDisk ${baseDisk}`, { timeout: 30000 })
    } catch (err) {
      console.warn('[Config] Mount attempt:', err.message)
    }

    // Wait for mount and find the boot partition
    let bootPath = null
    for (let i = 0; i < 10; i++) {
      await new Promise(resolve => setTimeout(resolve, 1000))

      // Check common boot partition names
      const possiblePaths = [
        '/Volumes/NO NAME',
        '/Volumes/boot',
        '/Volumes/bootfs',
        '/Volumes/BOOT'
      ]

      for (const p of possiblePaths) {
        if (fs.existsSync(p) && fs.existsSync(path.join(p, 'config.txt'))) {
          bootPath = p
          break
        }
      }

      if (bootPath) break
    }

    if (!bootPath) {
      throw new Error('Could not find boot partition after flashing')
    }

    // Write device config
    const configPath = path.join(bootPath, 'palpable-device.json')
    const userId = store.get('userId')

    const config = {
      deviceId,
      deviceName: deviceName || 'Palpable Device',
      userId,
      apiKey: pairingCode || null,
      createdAt: new Date().toISOString()
    }

    console.log('[Config] Writing config to:', configPath)
    fs.writeFileSync(configPath, JSON.stringify(config, null, 2))

    console.log('[Config] Device config written successfully')

  } else if (platform === 'linux') {
    // Linux: similar approach, mount and write
    const { execSync } = require('child_process')

    // Try to mount the first partition
    const partition = targetDevice + '1'
    const mountPoint = '/tmp/palpable-boot'

    try {
      execSync(`mkdir -p ${mountPoint}`)
      execSync(`mount ${partition} ${mountPoint}`)

      const configPath = path.join(mountPoint, 'palpable-device.json')
      const userId = store.get('userId')

      const config = {
        deviceId,
        deviceName: deviceName || 'Palpable Device',
        userId,
        apiKey: pairingCode || null,
        createdAt: new Date().toISOString()
      }

      fs.writeFileSync(configPath, JSON.stringify(config, null, 2))
      execSync(`umount ${mountPoint}`)
      console.log('[Config] Device config written successfully')
    } catch (err) {
      console.warn('[Config] Linux config write failed:', err.message)
      throw err
    }

  } else if (platform === 'win32') {
    // Windows: the partition should auto-mount, find the drive letter
    // This is more complex - for now, skip on Windows
    console.warn('[Config] Windows config writing not yet implemented')
  }
}

// Flash image with sudo
async function flashWithSudo(imagePath, targetDevice, onProgress) {
  return new Promise((resolve, reject) => {
    // Normalize device path to the disk (not partition)
    const platform = process.platform
    let device = targetDevice
    let command = ''

    if (platform === 'darwin') {
      // Strip partition suffix (e.g., disk2s1 -> disk2)
      device = device.replace(/s\d+$/, '')
      const rawDevice = device.replace('/dev/disk', '/dev/rdisk')

      // Use sudo-prompt which creates a proper privileged helper
      // This is the most reliable method for macOS disk writes
      command = `diskutil unmountDisk ${device} && dd if="${imagePath}" of=${rawDevice} bs=1m conv=sync status=none`

      console.log('[Flash] Using sudo-prompt for macOS')
      // Fall through to use sudo-prompt below
    } else if (platform === 'darwin_osascript_broken') {
      // osascript approach - doesn't work due to macOS security restrictions
      device = device.replace(/s\d+$/, '')
      const ddCommand = `diskutil unmountDisk ${device} && dd if=\\"${imagePath}\\" of=${device} bs=1m`
      command = `osascript -e 'do shell script "${ddCommand}" with administrator privileges'`
    } else if (platform === 'linux') {
      // Strip partition suffix (e.g., /dev/sdb1 -> /dev/sdb)
      device = device.replace(/p?\d+$/, '')
      command = `umount ${device}* 2>/dev/null; dd if="${imagePath}" of=${device} bs=4M status=progress conv=fsync`
    } else if (platform === 'win32') {
      // Windows: Use diskpart + dd for Windows
      // Get disk number from device path (e.g., \\.\PhysicalDrive2 -> 2)
      const diskNumber = device.match(/\d+$/)?.[0]
      if (!diskNumber) {
        reject(new Error('Invalid Windows disk device path'))
        return
      }

      // Use PowerShell with raw disk writes
      // Note: This requires admin privileges (handled by sudo-prompt)
      const imagePath_escaped = imagePath.replace(/\\/g, '\\\\').replace(/"/g, '\\"')
      command = `powershell -Command "& {` +
        `$disk = Get-Disk -Number ${diskNumber}; ` +
        `Clear-Disk -Number ${diskNumber} -RemoveData -RemoveOEM -Confirm:$false; ` +
        `$stream = [System.IO.File]::OpenRead('${imagePath_escaped}'); ` +
        `$device = [System.IO.File]::OpenWrite('\\\\\\\\.\\\\PhysicalDrive${diskNumber}'); ` +
        `$buffer = New-Object byte[] 4194304; ` +
        `while (($read = $stream.Read($buffer, 0, $buffer.Length)) -gt 0) { ` +
        `$device.Write($buffer, 0, $read); $device.Flush() }; ` +
        `$device.Close(); $stream.Close() }"`
    } else {
      reject(new Error('Unsupported platform for flashing'))
      return
    }

    const options = { name: 'Palpable Imager' }

    console.log('[Flash] Running sudo command:', command)
    sudo.exec(command, options, (error, stdout, stderr) => {
      if (error) {
        console.error('[Flash] sudo error:', error)
        console.error('[Flash] stdout:', stdout)
        console.error('[Flash] stderr:', stderr)
        const errorOutput = stderr || stdout || error.message || 'Flash failed'

        // Try to remount the disk on error (prevents auto-eject)
        if (platform === 'darwin') {
          spawn('diskutil', ['mountDisk', device], { detached: true, stdio: 'ignore' }).unref()
        }

        // Detect permission errors and provide helpful guidance
        if (errorOutput.includes('Operation not permitted') ||
            errorOutput.includes('Permission denied') ||
            errorOutput.includes('not authorized') ||
            errorOutput.includes('Access is denied') ||
            errorOutput.includes('UnauthorizedAccessException')) {

          let permissionMessage = ''

          if (platform === 'darwin') {
            // Open System Settings directly to Full Disk Access
            shell.openExternal('x-apple.systempreferences:com.apple.preference.security?Privacy_AllFiles')

            permissionMessage = 'Permission denied: Palpable Imager needs Full Disk Access to flash SD cards.\n\n' +
              'System Settings has been opened for you.\n\n' +
              'To fix this:\n' +
              '1. Click the lock icon and authenticate\n' +
              '2. Click the + button\n' +
              '3. Navigate to and select Palpable Imager\n' +
              '4. Enable the checkbox next to it\n' +
              '5. Restart Palpable Imager\n\n' +
              'Then try flashing again.'
          } else if (platform === 'win32') {
            permissionMessage = 'Permission denied: Administrator privileges are required to flash SD cards.\n\n' +
              'Please make sure you:\n' +
              '1. Run Palpable Imager as Administrator (right-click â†’ Run as Administrator)\n' +
              '2. Accept the User Account Control (UAC) prompt when flashing\n\n' +
              'Then try flashing again.'
          } else {
            permissionMessage = 'Permission denied: Root privileges are required to flash SD cards.\n\n' +
              'Please make sure you accept the sudo password prompt when flashing.\n\n' +
              'Then try flashing again.'
          }

          const permissionError = new Error(permissionMessage)
          permissionError.code = 'PERMISSION_DENIED'
          reject(permissionError)
          return
        }

        // Other errors
        reject(new Error(errorOutput))
      } else {
        onProgress(100)
        resolve()
      }
    })

    // Progress estimation
    let progress = 0
    const interval = setInterval(() => {
      if (progress < 95) {
        progress += 2
        onProgress(progress)
      }
    }, 1000)

    // Clear interval after typical flash time (will be overwritten by actual completion)
    setTimeout(() => clearInterval(interval), 300000) // 5 min max
  })
}

// Get user's devices
ipcMain.handle('get-devices', async () => {
  try {
    let token = await getValidToken()

    if (!token) {
      return { success: false, devices: [] }
    }

    try {
      const response = await got.get(`${PALPABLE_API_URL}/devices`, {
        headers: { Authorization: `Bearer ${token}` },
        responseType: 'json'
      })

      return {
        success: true,
        devices: response.body.devices || []
      }
    } catch (err) {
      // If 401, try refreshing the token and retry once
      if (err.response?.statusCode === 401) {
        console.log('[Auth] Got 401, attempting token refresh...')
        const newToken = await refreshAccessToken()
        if (newToken) {
          const response = await got.get(`${PALPABLE_API_URL}/devices`, {
            headers: { Authorization: `Bearer ${newToken}` },
            responseType: 'json'
          })
          return {
            success: true,
            devices: response.body.devices || []
          }
        } else {
          // Refresh failed - notify renderer to prompt re-auth
          if (mainWindow) {
            mainWindow.webContents.send('reauth-required', {
              reason: 'Your session has expired. Please sign in again to continue.'
            })
          }
          return { success: false, devices: [], error: 'Session expired', requiresReauth: true }
        }
      }
      throw err
    }
  } catch (err) {
    console.error('Failed to get devices:', err)
    return { success: false, devices: [], error: err.message }
  }
})

// Update device
ipcMain.handle('update-device', async (event, { deviceId, name, location, status }) => {
  try {
    const token = await getValidToken()

    if (!token) {
      return { success: false, error: 'Not authenticated' }
    }

    const response = await got.patch(`${PALPABLE_API_URL}/devices/${deviceId}`, {
      json: { name, location, status },
      headers: { Authorization: `Bearer ${token}` },
      responseType: 'json'
    })

    return {
      success: true,
      device: response.body.device
    }
  } catch (err) {
    console.error('Failed to update device:', err)
    const errorMessage = err.response?.body?.error || err.message
    return { success: false, error: errorMessage }
  }
})

// Delete device
ipcMain.handle('delete-device', async (event, { deviceId }) => {
  try {
    const token = await getValidToken()

    if (!token) {
      return { success: false, error: 'Not authenticated' }
    }

    const response = await got.delete(`${PALPABLE_API_URL}/devices/${deviceId}`, {
      headers: { Authorization: `Bearer ${token}` },
      responseType: 'json'
    })

    return {
      success: true
    }
  } catch (err) {
    console.error('Failed to delete device:', err)
    const errorMessage = err.response?.body?.error || err.message
    return { success: false, error: errorMessage }
  }
})

// Register device with Palpable account (or re-flash existing)
ipcMain.handle('register-device', async (event, { deviceName, deviceId }) => {
  try {
    const token = await getValidToken()
    const userId = store.get('userId')

    if (!token || !userId) {
      return { success: false, error: 'Not authenticated' }
    }

    const response = await got.post(`${PALPABLE_API_URL}/devices/register`, {
      json: { deviceName, userId, deviceId },
      headers: { Authorization: `Bearer ${token}` },
      responseType: 'json'
    })

    return {
      success: true,
      deviceId: response.body.deviceId,
      pairingCode: response.body.pairingCode
    }
  } catch (err) {
    console.error('Failed to register device:', err)
    return { success: false, error: err.message }
  }
})

// Get user's saved WiFi networks
ipcMain.handle('get-wifi-networks', async () => {
  try {
    const token = await getValidToken()

    if (!token) {
      return { success: false, networks: [] }
    }

    const response = await got.get(`${PALPABLE_API_URL}/wifi`, {
      headers: { Authorization: `Bearer ${token}` },
      responseType: 'json'
    })

    return { success: true, networks: response.body.networks }
  } catch (err) {
    console.error('Failed to get WiFi networks:', err)
    return { success: false, networks: [], error: err.message }
  }
})

// ============================================
// PAIRING CODE AUTH (Alternative to Browser OAuth)
// ============================================

// Validate pairing code (check if valid without redeeming)
ipcMain.handle('validate-pairing-code', async (event, { pairingCode }) => {
  try {
    const response = await got.get(`${PALPABLE_API_URL}/devices/pair?code=${pairingCode}`, {
      responseType: 'json'
    })
    
    return response.body
  } catch (err) {
    console.error('Failed to validate pairing code:', err)
    return { valid: false, error: err.message }
  }
})

// Authenticate using pairing code
// This links the imager to an existing device with a pairing code
ipcMain.handle('auth-with-pairing-code', async (event, { pairingCode }) => {
  try {
    const response = await got.post(`${PALPABLE_API_URL}/devices/pair`, {
      json: { pairingCode },
      responseType: 'json'
    })
    
    if (response.body.success) {
      // Store device info for this session
      store.set('pairedDeviceId', response.body.deviceId)
      store.set('pairedDeviceName', response.body.deviceName)
      store.set('pairedUserId', response.body.userId)
      
      // Notify renderer of successful pairing
      if (mainWindow) {
        mainWindow.webContents.send('pairing-success', {
          deviceId: response.body.deviceId,
          deviceName: response.body.deviceName,
          userId: response.body.userId
        })
      }
      
      return { 
        success: true, 
        deviceId: response.body.deviceId,
        deviceName: response.body.deviceName
      }
    }
    
    return { success: false, error: response.body.error || 'Pairing failed' }
  } catch (err) {
    console.error('Failed to auth with pairing code:', err)
    const errorMessage = err.response?.body?.error || err.message
    return { success: false, error: errorMessage }
  }
})

// Get pairing state
ipcMain.handle('get-pairing-state', () => {
  return {
    deviceId: store.get('pairedDeviceId'),
    deviceName: store.get('pairedDeviceName'),
    userId: store.get('pairedUserId'),
    isPaired: !!store.get('pairedDeviceId')
  }
})

// Clear pairing (for re-flashing different device)
ipcMain.handle('clear-pairing', () => {
  store.delete('pairedDeviceId')
  store.delete('pairedDeviceName')
  store.delete('pairedUserId')
  return { success: true }
})

// ============================================
// AUTO-UPDATE (generic feed on Netlify)
// ============================================

function logEvent(scope, message, data) {
  const payload = data ? ` ${JSON.stringify(data)}` : ''
  console.log(`[${scope}] ${message}${payload}`)
}

async function checkForUpdates() {
  if (!app.isPackaged) {
    return { success: false, error: 'Updates are only available in packaged builds.' }
  }

  try {
    logEvent('Update', 'Checking for updates')
    const result = await autoUpdater.checkForUpdates()
    const info = result?.updateInfo
    const currentVersion = app.getVersion()
    const latestVersion = info?.version
    logEvent('Update', 'Versions', { currentVersion, latestVersion })

    if (info && latestVersion && latestVersion !== currentVersion) {
      logEvent('Update', 'Update available')
      return { success: true, updateAvailable: true, version: latestVersion }
    }

    logEvent('Update', 'Already up to date')
    return { success: true, updateAvailable: false, version: currentVersion }
  } catch (err) {
    logEvent('Update', 'Check failed', { error: err.message })
    return { success: false, error: err.message }
  }
}

// Manual check for updates (from renderer)
ipcMain.handle('check-for-updates', async () => {
  return await checkForUpdates()
})

// AutoUpdater events
if (app.isPackaged) {
  autoUpdater.on('update-available', (info) => {
    logEvent('Update', 'Update available event', { version: info?.version })
    if (mainWindow) {
      mainWindow.webContents.send('update-available', { version: info?.version })
    }
  })

  autoUpdater.on('update-not-available', (info) => {
    logEvent('Update', 'No update available', { version: info?.version })
    if (mainWindow) {
      mainWindow.webContents.send('update-not-available', { currentVersion: app.getVersion() })
    }
  })

  autoUpdater.on('download-progress', (progress) => {
    const percent = Math.round(progress.percent || 0)
    logEvent('Update', 'Download progress', { percent })
    if (mainWindow) {
      mainWindow.setProgressBar((progress.percent || 0) / 100)
      mainWindow.webContents.send('update-download-progress', { percent })
    }
  })

  autoUpdater.on('update-downloaded', (info) => {
    logEvent('Update', 'Update downloaded', { version: info?.version, path: info?.path })
    // Store update info for manual installation (needed for ad-hoc signed apps)
    downloadedUpdateInfo = info
    if (mainWindow) {
      mainWindow.setProgressBar(-1)
      mainWindow.webContents.send('update-downloaded', { version: info?.version })
      // Don't show dialog - let the renderer handle it with the modal
    }
  })

  autoUpdater.on('error', (err) => {
    logEvent('Update', 'Update error', { error: err.message, stack: err.stack })

    if (mainWindow) {
      mainWindow.setProgressBar(-1)

      // Don't show error for signature verification on macOS (expected for ad-hoc signed apps)
      const isSignatureError = err.message && (
        err.message.includes('code signature') ||
        err.message.includes('code failed to satisfy') ||
        err.message.includes('signature validation')
      )

      if (process.platform === 'darwin' && isSignatureError) {
        // Expected for ad-hoc signed macOS apps - silently ignore
        logEvent('Update', 'Signature error ignored (ad-hoc signed app)')
        return
      }

      // Prevent duplicate error popups (only show once per 60 seconds)
      const now = Date.now()
      const errorMessage = err.message || 'Unknown error'
      if (lastUpdateError === errorMessage && (now - lastUpdateErrorTime) < 60000) {
        logEvent('Update', 'Duplicate error suppressed', { message: errorMessage })
        return
      }

      // Track this error
      lastUpdateError = errorMessage
      lastUpdateErrorTime = now

      // Send to renderer to show in UI (don't show native dialog - that creates doubles)
      mainWindow.webContents.send('update-error', { message: errorMessage })
    }
  })
}

// Get app version
ipcMain.handle('get-app-version', () => {
  return app.getVersion()
})

// Manual update installation for ad-hoc signed apps (bypasses signature verification)
async function installUpdateManually(updateInfo) {
  if (process.platform !== 'darwin') {
    // For non-macOS, use standard method
    autoUpdater.quitAndInstall(false, true)
    return
  }

  try {
    logEvent('Update', 'Starting manual installation', { version: updateInfo?.version, updateInfo })
    
    // Get the downloaded update path
    // electron-updater stores updates in ~/Library/Caches/app.palpable.imager.ShipIt/update.{random}/
    let updatePath = updateInfo?.path || updateInfo?.downloadPath || updateInfo?.cacheDir
    
    // If path not provided, try to find it in the ShipIt cache
    if (!updatePath || !fs.existsSync(updatePath)) {
      const cacheDir = path.join(app.getPath('userData'), '..', 'Caches', 'app.palpable.imager.ShipIt')
      if (fs.existsSync(cacheDir)) {
        const entries = fs.readdirSync(cacheDir)
        const updateDirs = entries.filter(e => e.startsWith('update.'))
        if (updateDirs.length > 0) {
          // Use the most recent update directory
          updateDirs.sort().reverse()
          updatePath = path.join(cacheDir, updateDirs[0])
          logEvent('Update', 'Found update in cache', { updatePath })
        }
      }
    }
    
    if (!updatePath || !fs.existsSync(updatePath)) {
      throw new Error('Update path not found. Please try downloading the update again.')
    }

    logEvent('Update', 'Update path', { updatePath })

    // Find the actual .app bundle in the update directory
    let updateAppPath = null
    
    // Check if updatePath is already the .app
    if (updatePath.endsWith('.app') && fs.existsSync(updatePath)) {
      updateAppPath = updatePath
    } else {
      // Search for .app in the directory
      function findAppBundle(dir, depth = 0) {
        if (depth > 3) return null // Limit search depth
        
        try {
          const entries = fs.readdirSync(dir)
          for (const entry of entries) {
            const fullPath = path.join(dir, entry)
            const stat = fs.statSync(fullPath)
            
            if (entry.endsWith('.app') && stat.isDirectory()) {
              return fullPath
            }
            
            if (stat.isDirectory() && !entry.startsWith('.')) {
              const found = findAppBundle(fullPath, depth + 1)
              if (found) return found
            }
          }
        } catch (err) {
          // Ignore errors
        }
        return null
      }
      
      updateAppPath = findAppBundle(updatePath)
    }
    
    if (!updateAppPath || !fs.existsSync(updateAppPath)) {
      throw new Error('Could not find .app bundle in update. The update may be corrupted.')
    }

    logEvent('Update', 'Found update app bundle', { updateAppPath })

    // Get current app path
    const currentAppPath = app.getPath('exe')
    const currentAppDir = path.dirname(currentAppPath)
    const currentAppName = path.basename(currentAppPath, '.app')
    
    // Escape paths for shell script
    const escapePath = (p) => p.replace(/'/g, "'\"'\"'")
    const escapedUpdateApp = escapePath(updateAppPath)
    const escapedCurrentDir = escapePath(currentAppDir)
    const escapedAppName = escapePath(currentAppName)

    // Create installation script
    const scriptPath = path.join(app.getPath('temp'), `install-update-${Date.now()}.sh`)
    const script = `#!/bin/bash
set -e

# Wait for app to quit
sleep 2

# Remove quarantine attribute from update
xattr -cr '${escapedUpdateApp}' || true

# Determine installation location
INSTALL_DIR=""
INSTALL_PATH=""

# Try Applications folder first
if [ -d "/Applications" ]; then
  INSTALL_DIR="/Applications"
  INSTALL_PATH="/Applications/Palpable-Imager.app"
else
  # Fall back to current location
  INSTALL_DIR='${escapedCurrentDir}'
  INSTALL_PATH="'${escapedCurrentDir}'/'${escapedAppName}'.app"
fi

# Remove old app if it exists
if [ -d "$INSTALL_PATH" ]; then
  rm -rf "$INSTALL_PATH"
fi

# Copy update to installation location
cp -R '${escapedUpdateApp}' "$INSTALL_PATH"

# Remove quarantine from installed app
xattr -cr "$INSTALL_PATH" 2>/dev/null || true

# Open the app
open "$INSTALL_PATH" 2>/dev/null || true

# Clean up script
rm -f '${scriptPath}'
`

    fs.writeFileSync(scriptPath, script)
    fs.chmodSync(scriptPath, '755')

    logEvent('Update', 'Created installation script', { scriptPath })

    // Execute script in background and quit
    spawn('bash', [scriptPath], {
      detached: true,
      stdio: 'ignore'
    }).unref()

    // Give script a moment to start
    setTimeout(() => {
      app.quit()
    }, 500)

  } catch (err) {
    logEvent('Update', 'Manual installation failed', { error: err.message, stack: err.stack })
    throw err
  }
}

// Restart and install update
ipcMain.handle('restart-and-install', async () => {
  if (app.isPackaged) {
    try {
      // For ad-hoc signed apps (identity: null), auto-update doesn't work reliably
      // Direct users to download from GitHub instead
      const isAdHocSigned = process.platform === 'darwin' // Assuming macOS builds are ad-hoc signed

      if (isAdHocSigned) {
        logEvent('Update', 'Ad-hoc signed app - directing to GitHub releases')

        // Open GitHub releases page
        await shell.openExternal('https://github.com/epode-studio/palpable-imager/releases/latest')

        // Show message to user
        if (mainWindow) {
          const { response } = await dialog.showMessageBox(mainWindow, {
            type: 'info',
            title: 'Manual Update Required',
            message: 'Download the latest version from GitHub',
            detail: 'The GitHub releases page has been opened in your browser.\n\n' +
                    '1. Download the .dmg file\n' +
                    '2. Open it and replace the old app\n' +
                    '3. Restart Palpable Imager\n\n' +
                    'Would you like to quit now to install the update?',
            buttons: ['Quit Now', 'Later'],
            defaultId: 0,
            cancelId: 1
          })

          if (response === 0) {
            app.quit()
          }
        }
      } else {
        // For properly signed apps or other platforms, use standard method
        autoUpdater.quitAndInstall(false, true) // isSilent=false, isForceRunAfter=true
      }
    } catch (err) {
      console.error('Failed to restart and install:', err)
      logEvent('Update', 'Restart failed', { error: err.message })

      // Show error to user
      if (mainWindow) {
        dialog.showErrorBox(
          'Update Installation Failed',
          `Failed to install update: ${err.message}\n\nPlease download and install the update manually from GitHub releases.`
        )
      }
    }
  }
})

